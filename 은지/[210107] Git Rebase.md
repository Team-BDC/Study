# 1. Git Branch

> 개발 시 코드를 복사하여 원래 코드와 독립적으로 개발을 진행하는 것. 협업이나 버전관리에서 유용하다.
> Git은 데이터를 스냅샷으로 저장하고, 커밋할 경우 커밋 개체(스냅샷에 대한 포인터, 메타데이터, 이전 커밋에 대한 포인터 등)을 저장하며, 이 커밋 개체가 있기 때문에 언제든지 스냅샷을 만들 수 있다.

## 1-1. Git Branch2

- git branch [브랜치명]
  마지막 커밋을 가리키는 새로 브랜치를 만든다. 즉 만들기만 하고 옮기지는 않는다.
- git log --oneline --decorate
  브랜치가 어떤 커밋을 가리키는지 알 수 있다. HEAD는 현재 브랜치를 가리킨다.
- git checkout [브랜치명]
  다른 브랜치로 이동한다.
  이때 새 브랜치에 커밋하면, master 브랜치, 즉 이전 커밋을 가리키는 브랜치보다 앞 단계에 위치하므로 브랜치가 갈라져 독립적으로 동작한다.
- git log --oneline --decorate --graph --all
  현재 브랜치의 히스토리를 출력한다.

## 1-2. Git Rebase

> 깃에서 한 브랜치에서 다른 브랜치로 합치는 방법은 Merge와 Rebase 두 가지가 있다. Merge는 권장되지 않는다고 하므로, Rebase를 활용하여 브랜치를 관리하도록 공부한다.

### Merge와 Rebase의 차이

> 이전 커밋 C2와 master 브랜치가 가리키는 커밋 C3, 그리고 나누어진 브랜치, experiment가 가리키는 커밋 C4가 있다고 가정한다.

- Merge

  C3과 C4의 마지막 커밋 두개와 공통 조상인 C2를 사용하는 3-way Merge로 새로운 커밋 C5를 만든다.

- Rebase

  C3에서 변경된 사항을 Patch로 만들고, 이를 C4에 적용한다.

> 즉 Rebase는 한 브랜치에서 변경된 사항을 다른 브랜치에 적용한다!

### Rebase 과정

- git checkout [브랜치명]
- git rebase master
  > 이렇게 하면 공통 커밋 C2로 이동한 후, 지금 checkout한 브랜치, experiment가 가리키는 커밋까지 diff를 만들고 다른 곳에 저장한다. 이후 rebase할 브랜치 experiment가 합칠 브랜치 master가 가리키는 커밋을 가리키게 하고, 앞서 다른 곳에 저장한 변경사항 diff를 차례로 적용한다.
- git checkout master
- git merge experiment
  > 이후 master 브랜치를 Fast-forward 한다.

## 1-3. Rebase를 쓰는 이유

### Merge와의 차이

- rebase : 변경사항을 순서대로 다른 브랜치에 적용하면서 합친다.
- merge : 두 브랜치의 최종 결과만을 가지고 합친다.

> Merge에 비해 깨끗한 히스토리 관리가 가능하다. 병렬 진행되더라도 rebase하고 나면 선형으로 차례대로 수행된 것처럼 보이기 때문. 즉, 보통 리모트 브랜치에 커밋을 깔끔하게 적용하고 싶을 때 사용한다.
> 최종 결과물은 같고 커밋 히스토리만 달라진다!

### Rebase vs Merge ?

> 각자 상황에 따라 사용하는 것이 best.
> 단, history 관리는 프로젝트 진행 과정의 측면에서도 중요하므로, 로컬에서 작업할 때는 rebase를 추천. 단, 리모트 등 어딘가로 push 보낸 커밋의 경우 절대 비추천.

## 1-4. Rebase의 활용

> 브랜치가 여러 개로 갈라졌는데, 일부는 master과 합치고 일부는 아직 덜 끝나서 내버려두고 싶은 경우.
> 브랜치를 삭제해도 커밋 히스토리는 최종 커밋 히스토리에 여전히 남는다.

## 1-5. Rebase의 위험성

### 이미 공개된 저장소에 PUSH한 커밋을 Rebase하지 마라!

> 기존 커밋을 그대로 사용하는 것이 아닌, 내용만 같은 완전히 새로운 커밋을 만드는 것!
> 새 커밋이 push된 후, 동료가 pull했는데 내가 해당 커밋을 rebase하면 동료가 push한 후 다시 merge해야한다. 그리고 또 merge 내용을 pull해야하는 등 굉장히 복잡해진다..!

### 해결방법

> Rebase한 것을 다시 Rebase해라.
> 팀원이 내가 한 일을 강제로 덮어쓴 경우, Rebase를 통해 덮어쓴 커밋을 원래 누가 작성한 코드인지 찾아낼 수 있다. 따라서 patch가 잘 작동한다.

1. 팀원a가 팀원b가 의존하는 커밋을 없앤 후 rebase한 커밋을 push했다
2. git rebase teamone/master

- 현재 브랜치에 포함된 커밋을 찾는다.
- merge 커밋을 가려낸다.
- 이 중 덮어쓰지 않은 커밋들을 골라낸다.
- 남은 커밋들만 teamone/master 바탕으로 커밋을 쌓는다.

3. 결과 : 강제로 덮어쓴 브랜치에 rebase할 수 있다.
